cat("---------------------------\n")
for (i in seq_along(missingTestTable$Column)) {
cat(sprintf("%-15s %-15d\n", missingTestTable$Column[i], missingTestTable$MissingTestCount[i]))
}
# Load necessary libraries
library(ggplot2)
library(tidyr)
# Define the number of rows and columns for the subplot matrix
num_rows <- 2
num_cols <- 7
# Select only the continuous and discrete integer columns from the mobileTrain dataset
selected_cols <- mobileTrain[, c("battery_power", "fc", "int_memory", "mobile_wt",
"n_cores", "pc", "px_height", "px_width", "ram",
"sc_h", "sc_w", "talk_time", "clock_speed", "m_dep")]
# Convert the selected data frame to long format
mobileTrain_long <- tidyr::pivot_longer(selected_cols,
cols = everything(),
names_to = "name", values_to = "value")
# Convert the 'name' column to a factor or character variable
mobileTrain_long$name <- as.factor(mobileTrain_long$name)
# Create the boxplot using ggplot2 with mean markers
trainingPlots <- ggplot(mobileTrain_long, aes(x = name, y = value)) +
geom_boxplot() +
stat_boxplot(geom = "errorbar", width = 0.2, position = position_dodge(width = 0.75)) +
stat_summary(fun = mean, geom = "point", shape = 5, size = 3, color = "red",
position = position_dodge(width = 0.75)) +
facet_wrap(~name, scales = "free_x", ncol = num_cols) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Print the plot
print(trainingPlots)
# Comparison of Integer and Continuous Variables PRE Normalization
# Integer
hist(mobileTrain$int_memory, main="Internal Memory Megapixels Frequency of Mobile Phones", xlab="Internal Memory", col="lightblue")
hist(mobileTrain$ram, main="RAM Frequency of Mobile Phones", xlab="RAM", col="darkmagenta")
#Continuous
hist(mobileTrain$clock_speed, main="Clock Speed Frequency of Mobile Phones", xlab="Clock Speed", col="lightpink")
# Load necessary libraries
library(dplyr)
# Min-Max scaling
min_max_norm <- function(x) {(x - min(x)) / (max(x) - min(x))}
#Apply normalization to necessacry columns (all columns - target)
normalized_mobileTrain <- as.data.frame(lapply(mobileTrain[1:20], min_max_norm))
#Add target variable (price_range) back
normalized_mobileTrain$price_range <- mobileTrain$price_range
#Validate normalization and target variable
head(normalized_mobileTrain)
# Load necessary libraries
library(ggplot2)
library(tidyr)
# Define the number of rows and columns for the subplot matrix
num_rows <- 2
num_cols <- 7
# Select only the continuous and discrete integer columns from the mobileTrain dataset
selected_cols <- normalized_mobileTrain[, c("battery_power", "fc", "int_memory", "mobile_wt",
"n_cores", "pc", "px_height", "px_width", "ram",
"sc_h", "sc_w", "talk_time", "clock_speed", "m_dep")]
# Convert the selected data frame to long format
mobileTrain_long <- tidyr::pivot_longer(selected_cols,
cols = everything(),
names_to = "name", values_to = "value")
# Convert the 'name' column to a factor or character variable
mobileTrain_long$name <- as.factor(mobileTrain_long$name)
# Create the boxplot using ggplot2 with mean markers
trainingPlots <- ggplot(mobileTrain_long, aes(x = name, y = value)) +
geom_boxplot() +
stat_boxplot(geom = "errorbar", width = 0.2, position = position_dodge(width = 0.75)) +
stat_summary(fun = mean, geom = "point", shape = 5, size = 3, color = "red",
position = position_dodge(width = 0.75)) +
facet_wrap(~name, scales = "free_x", ncol = num_cols) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Print the plot
print(trainingPlots)
# Function to calculate z-scores for a vector
calculate_z_scores <- function(x) {
(x - mean(x)) / sd(x)
}
# Calculate z-scores for each column
z_scores <- mobileTrain_long %>%
group_by(name) %>%
mutate(z_score = calculate_z_scores(value))
# Set the z-score threshold for outlier detection
z_score_threshold <- 3
# Identify outliers based on z-scores
outliers <- z_scores %>%
dplyr::filter(abs(z_score) > z_score_threshold)
# Print the outliers
print(outliers)
# Load necessary libraries
library(dplyr)
# Calculate z-scores for each column
z_scores <- apply(normalized_mobileTrain, 2, function(x) abs((x - mean(x)) / sd(x)))
# Find rows with z-scores greater than 3 in any column
outliers <- rowSums(z_scores > 3) > 0
# Filter out the outliers from the dataset
filtered_mobileTrain <- normalized_mobileTrain[!outliers, ]
# get dimensions of the filtered dataset
dim(filtered_mobileTrain)
# Load necessary libraries
library(dplyr)
# Calculate z-scores for each column
z_scores <- apply(normalized_mobileTrain, 2, function(x) abs((x - mean(x)) / sd(x)))
# Find rows with z-scores greater than 3 in any column
outliers <- rowSums(z_scores > 3) > 0
# Filter out the outliers from the dataset
filtered_mobileTrain <- normalized_mobileTrain[!outliers, ]
# Print summary statistics of the original dataset
print(summary(normalized_mobileTrain))
# Print summary statistics of the filtered dataset
print(summary(filtered_mobileTrain))
library(ggplot2)
# Define the number of rows and columns for the subplot matrix
num_rows <- 2
num_cols <- 7
numeric_vars <- c("battery_power","clock_speed", "fc", "int_memory", "m_dep",	"mobile_wt", "n_cores","pc", "px_height",	"px_width", "ram", "sc_h", "sc_w", "talk_time")
# Select only the numeric variables from the filtered_mobileTrain dataset
selected_cols <- filtered_mobileTrain %>%
select(all_of(numeric_vars))
# Convert the column names to a factor or character variable
selected_cols <- selected_cols %>%
gather(name, value)
# Create the boxplot using ggplot2 with mean markers
trainingPlotsFiltered <- ggplot(selected_cols, aes(x = name, y = value)) +
geom_boxplot() +
stat_boxplot(geom = "errorbar", width = 0.2, position = position_dodge(width = 0.75)) +
stat_summary(fun = mean, geom = "point", shape = 5, size = 3, color = "red",
position = position_dodge(width = 0.75)) +
facet_wrap(~name, scales = "free_x", ncol = num_cols) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Print the plot
print(trainingPlotsFiltered)
# Load necessary libraries
library(ggplot2)
# Select only the binary columns from the normalized_mobileTrain dataset
binary_cols <- filtered_mobileTrain[, c("blue", "dual_sim", "four_g", "three_g", "touch_screen", "wifi")]
# Get the table of counts for each binary variable
binary_counts <- lapply(binary_cols, table)
# Combine the counts into a single data frame
binary_df <- do.call(rbind, lapply(names(binary_counts), function(var_name) {
data.frame(Variable = rep(var_name, 2),
Value = as.factor(c("0", "1")),
Count = as.numeric(binary_counts[[var_name]]))
}))
# Create the heatmap using ggplot2
heatmap_plot <- ggplot(binary_df, aes(x = Variable, y = Value, fill = Count)) +
geom_tile(color = "white") +
scale_fill_gradient(low = "lightblue", high = "darkblue") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Print the plot
print(heatmap_plot)
# Library
library(Hmisc)
# Correlation matrix of all Numeric Variables
#Data Frame of Numeric Variables
corr_train_data <- filtered_mobileTrain %>%
select(battery_power, fc, int_memory, mobile_wt, n_cores, pc, px_height, px_width, ram, sc_h, sc_w, talk_time, clock_speed, m_dep)
# Correlation Matrix followed by p-value matrix
#corr_train_data.cor = cor(corr_train_data)
#corr_train_data.cor #commented out to avoid redundancy
p_correlation = rcorr(as.matrix(corr_train_data))
p_correlation
# Heatmap of Integer Correlation
palette = colorRampPalette(c("lightgreen", "white", "red")) (30)
heatmap(x = corr_train_data.cor, col = palette, sym = TRUE)
knitr::opts_chunk$set(echo = TRUE)
# Load data files
mobileTrain <- read.csv("train.csv", header = TRUE)
mobileTest <- read.csv("test.csv", header = TRUE)
# Find training data set dimensions
dimenTrain <- dim(mobileTrain)
print(dimenTrain)
# Find testing data set dimensions
dimenTest <- dim(mobileTest)
print(dimenTest)
# suppressMessages()
suppressMessages({
# Load conflicted package
library(conflicted)
# Load the tidyverse package
library(tidyverse)
# Get the column names and data types
colnamesTrain <- colnames(mobileTrain)
dtypeTrain <- sapply(mobileTrain, class)
# Clean the output
colnamesTrain <- str_pad(colnamesTrain, 10, side = "left")
dtypeTrain <- str_pad(dtypeTrain, 10, side = "left")
# Combine the two into a single data frame
df <- tibble(
colname = colnamesTrain,
dtype = dtypeTrain
)
# Print the data frame
print(df)
})
# Load the tidyverse package
library(tidyverse)
# Get the column names and data types
colnamesTest <- colnames(mobileTest)
dtypeTest <- sapply(mobileTest, class)
# Clean the output
colnamesTest <- str_pad(colnamesTest, 10, side = "left")
dtypeTest <- str_pad(dtypeTest, 10, side = "left")
# Combine the two into a single data frame
df <- tibble(
colname = colnamesTest,
dtype = dtypeTest
)
# Print the data frame
print(df)
# Display summary statistics for the training data set
summaryTrain <- summary(mobileTrain)
print(summaryTrain)
# Display summary statistics for the training data set
summaryTest<- summary(mobileTest)
print(summaryTest)
# Get the sum of missing values for each column
missingTrain <- colSums(is.na(mobileTrain))
# Column names
trainColumnNames <- names(missingTrain)
# Create a new data frame with column names and missing value counts
missingTrainTable <- data.frame(Column = trainColumnNames, MissingTrainCount = missingTrain)
# Print the tidy table to the console
cat(sprintf("%-15s %-15s\n", "Column Name", "NA Count"))
cat("---------------------------\n")
for (i in seq_along(missingTrainTable$Column)) {
cat(sprintf("%-15s %-15d\n", missingTrainTable$Column[i], missingTrainTable$MissingTrainCount[i]))
}
# Get the sum of missing values for each column
missingTest <- colSums(is.na(mobileTest))
# Column names
testColumnNames <- names(missingTest)
# Create a new data frame with column names and missing value counts
missingTestTable <- data.frame(Column = testColumnNames, MissingTestCount = missingTest)
# Print the tidy table to the console
cat(sprintf("%-15s %-15s\n", "Column Name", "NA Count"))
cat("---------------------------\n")
for (i in seq_along(missingTestTable$Column)) {
cat(sprintf("%-15s %-15d\n", missingTestTable$Column[i], missingTestTable$MissingTestCount[i]))
}
# Load necessary libraries
library(ggplot2)
library(tidyr)
# Define the number of rows and columns for the subplot matrix
num_rows <- 2
num_cols <- 7
# Select only the continuous and discrete integer columns from the mobileTrain dataset
selected_cols <- mobileTrain[, c("battery_power", "fc", "int_memory", "mobile_wt",
"n_cores", "pc", "px_height", "px_width", "ram",
"sc_h", "sc_w", "talk_time", "clock_speed", "m_dep")]
# Convert the selected data frame to long format
mobileTrain_long <- tidyr::pivot_longer(selected_cols,
cols = everything(),
names_to = "name", values_to = "value")
# Convert the 'name' column to a factor or character variable
mobileTrain_long$name <- as.factor(mobileTrain_long$name)
# Create the boxplot using ggplot2 with mean markers
trainingPlots <- ggplot(mobileTrain_long, aes(x = name, y = value)) +
geom_boxplot() +
stat_boxplot(geom = "errorbar", width = 0.2, position = position_dodge(width = 0.75)) +
stat_summary(fun = mean, geom = "point", shape = 5, size = 3, color = "red",
position = position_dodge(width = 0.75)) +
facet_wrap(~name, scales = "free_x", ncol = num_cols) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Print the plot
print(trainingPlots)
# Comparison of Integer and Continuous Variables PRE Normalization
# Integer
hist(mobileTrain$int_memory, main="Internal Memory Megapixels Frequency of Mobile Phones", xlab="Internal Memory", col="lightblue")
hist(mobileTrain$ram, main="RAM Frequency of Mobile Phones", xlab="RAM", col="darkmagenta")
#Continuous
hist(mobileTrain$clock_speed, main="Clock Speed Frequency of Mobile Phones", xlab="Clock Speed", col="lightpink")
# Load necessary libraries
library(dplyr)
# Min-Max scaling
min_max_norm <- function(x) {(x - min(x)) / (max(x) - min(x))}
#Apply normalization to necessacry columns (all columns - target)
normalized_mobileTrain <- as.data.frame(lapply(mobileTrain[1:20], min_max_norm))
#Add target variable (price_range) back
normalized_mobileTrain$price_range <- mobileTrain$price_range
#Validate normalization and target variable
head(normalized_mobileTrain)
# Load necessary libraries
library(ggplot2)
library(tidyr)
# Define the number of rows and columns for the subplot matrix
num_rows <- 2
num_cols <- 7
# Select only the continuous and discrete integer columns from the mobileTrain dataset
selected_cols <- normalized_mobileTrain[, c("battery_power", "fc", "int_memory", "mobile_wt",
"n_cores", "pc", "px_height", "px_width", "ram",
"sc_h", "sc_w", "talk_time", "clock_speed", "m_dep")]
# Convert the selected data frame to long format
mobileTrain_long <- tidyr::pivot_longer(selected_cols,
cols = everything(),
names_to = "name", values_to = "value")
# Convert the 'name' column to a factor or character variable
mobileTrain_long$name <- as.factor(mobileTrain_long$name)
# Create the boxplot using ggplot2 with mean markers
trainingPlots <- ggplot(mobileTrain_long, aes(x = name, y = value)) +
geom_boxplot() +
stat_boxplot(geom = "errorbar", width = 0.2, position = position_dodge(width = 0.75)) +
stat_summary(fun = mean, geom = "point", shape = 5, size = 3, color = "red",
position = position_dodge(width = 0.75)) +
facet_wrap(~name, scales = "free_x", ncol = num_cols) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Print the plot
print(trainingPlots)
# Function to calculate z-scores for a vector
calculate_z_scores <- function(x) {
(x - mean(x)) / sd(x)
}
# Calculate z-scores for each column
z_scores <- mobileTrain_long %>%
group_by(name) %>%
mutate(z_score = calculate_z_scores(value))
# Set the z-score threshold for outlier detection
z_score_threshold <- 3
# Identify outliers based on z-scores
outliers <- z_scores %>%
dplyr::filter(abs(z_score) > z_score_threshold)
# Print the outliers
print(outliers)
# Load necessary libraries
library(dplyr)
# Calculate z-scores for each column
z_scores <- apply(normalized_mobileTrain, 2, function(x) abs((x - mean(x)) / sd(x)))
# Find rows with z-scores greater than 3 in any column
outliers <- rowSums(z_scores > 3) > 0
# Filter out the outliers from the dataset
filtered_mobileTrain <- normalized_mobileTrain[!outliers, ]
# get dimensions of the filtered dataset
dim(filtered_mobileTrain)
# Load necessary libraries
library(dplyr)
# Calculate z-scores for each column
z_scores <- apply(normalized_mobileTrain, 2, function(x) abs((x - mean(x)) / sd(x)))
# Find rows with z-scores greater than 3 in any column
outliers <- rowSums(z_scores > 3) > 0
# Filter out the outliers from the dataset
filtered_mobileTrain <- normalized_mobileTrain[!outliers, ]
# Print summary statistics of the original dataset
print(summary(normalized_mobileTrain))
# Print summary statistics of the filtered dataset
print(summary(filtered_mobileTrain))
library(ggplot2)
# Define the number of rows and columns for the subplot matrix
num_rows <- 2
num_cols <- 7
numeric_vars <- c("battery_power","clock_speed", "fc", "int_memory", "m_dep",	"mobile_wt", "n_cores","pc", "px_height",	"px_width", "ram", "sc_h", "sc_w", "talk_time")
# Select only the numeric variables from the filtered_mobileTrain dataset
selected_cols <- filtered_mobileTrain %>%
select(all_of(numeric_vars))
# Convert the column names to a factor or character variable
selected_cols <- selected_cols %>%
gather(name, value)
# Create the boxplot using ggplot2 with mean markers
trainingPlotsFiltered <- ggplot(selected_cols, aes(x = name, y = value)) +
geom_boxplot() +
stat_boxplot(geom = "errorbar", width = 0.2, position = position_dodge(width = 0.75)) +
stat_summary(fun = mean, geom = "point", shape = 5, size = 3, color = "red",
position = position_dodge(width = 0.75)) +
facet_wrap(~name, scales = "free_x", ncol = num_cols) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Print the plot
print(trainingPlotsFiltered)
# Load necessary libraries
library(ggplot2)
# Select only the binary columns from the normalized_mobileTrain dataset
binary_cols <- filtered_mobileTrain[, c("blue", "dual_sim", "four_g", "three_g", "touch_screen", "wifi")]
# Get the table of counts for each binary variable
binary_counts <- lapply(binary_cols, table)
# Combine the counts into a single data frame
binary_df <- do.call(rbind, lapply(names(binary_counts), function(var_name) {
data.frame(Variable = rep(var_name, 2),
Value = as.factor(c("0", "1")),
Count = as.numeric(binary_counts[[var_name]]))
}))
# Create the heatmap using ggplot2
heatmap_plot <- ggplot(binary_df, aes(x = Variable, y = Value, fill = Count)) +
geom_tile(color = "white") +
scale_fill_gradient(low = "lightblue", high = "darkblue") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Print the plot
print(heatmap_plot)
# Library
library(Hmisc)
# Correlation matrix of all Numeric Variables
#Data Frame of Numeric Variables
corr_train_data <- filtered_mobileTrain %>%
select(battery_power, fc, int_memory, mobile_wt, n_cores, pc, px_height, px_width, ram, sc_h, sc_w, talk_time, clock_speed, m_dep)
# Correlation Matrix followed by p-value matrix
#corr_train_data.cor = cor(corr_train_data)
#corr_train_data.cor #commented out to avoid redundancy
p_correlation = rcorr(as.matrix(corr_train_data))
p_correlation
# Load necessary libraries
library(dplyr)
# Define the numeric and categorical variables
numeric_vars <- c("battery_power", "fc", "int_memory", "mobile_wt", "n_cores", "pc", "px_height", "px_width", "ram", "sc_h", "sc_w", "talk_time", "clock_speed", "m_dep")
categorical_vars <- c("blue", "dual_sim", "four_g", "three_g", "touch_screen", "wifi")
# Perform Min-Max scaling and convert categorical variables to factors
filtered_factored_mobileTrain <- filtered_mobileTrain %>%
mutate_at(vars(all_of(categorical_vars)), as.factor) %>%
mutate(across(all_of(numeric_vars), ~ (.-min(.)) / (max(.) - min(.))))
# Calculate the covariance matrix for numeric variables
cov_matrix <- cov(filtered_factored_mobileTrain[, numeric_vars])
# Print covariance matrix with variable names
cat("Covariance Matrix for Numeric Variables:\n")
print(cov_matrix)
# Load necessary libraries
library(dplyr)
library(ggplot2)
library(reshape2)  # for melt function
# Define the numeric and categorical variables
numeric_vars <- c("battery_power", "fc", "int_memory", "mobile_wt", "n_cores", "pc", "px_height", "px_width", "ram", "sc_h", "sc_w", "talk_time", "clock_speed", "m_dep")
categorical_vars <- c("blue", "dual_sim", "four_g", "three_g", "touch_screen", "wifi")
# Perform Min-Max scaling and convert categorical variables to factors
filtered_factored_mobileTrain <- filtered_mobileTrain %>%
mutate_at(vars(all_of(categorical_vars)), as.factor) %>%
mutate(across(all_of(numeric_vars), ~ (.-min(.)) / (max(.) - min(.))))
# Calculate the correlation matrix for numeric variables
cov_matrix <- cov(filtered_factored_mobileTrain[, numeric_vars])
# Create a heatmap of the correlation matrix
heatmap_data <- as.data.frame(as.table(cov_matrix))
colnames(heatmap_data) <- c("Variable_1", "Variable_2", "Covariance")  # Replace spaces with underscores
# Create the heatmap
ggplot(heatmap_data, aes(x = Variable_1, y = Variable_2, fill = Covariance)) +
geom_tile() +
scale_fill_gradient2(low = "white", mid = "blue", high = "yellow", midpoint = 0) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))+
labs(title = "Covariance Heatmap for Numeric Variables")
# Calculate the correlation with the target variable
cor_with_target <- sapply(numeric_vars, function(var) cor(filtered_mobileTrain[[var]], filtered_mobileTrain$price_range))
# Print correlation values with the target variable neatly
cat("Correlation with the target variable (price_range):\n")
for (i in 1:length(numeric_vars)) {
cat(numeric_vars[i], ": ", cor_with_target[i], "\n")
}
# Calculate the correlation with the target variable
cor_with_target <- sapply(numeric_vars, function(var) cor(filtered_mobileTrain[[var]], filtered_mobileTrain$price_range))
# Create a data frame for plotting
cor_df <- data.frame(Variable = numeric_vars, Correlation = cor_with_target)
# Plot correlation values with the target variable using a bar plot
library(ggplot2)
ggplot(cor_df, aes(x = reorder(Variable, -Correlation), y = Correlation)) +
geom_bar(stat = "identity", fill = "dodgerblue") +
coord_flip() +
labs(title = "Correlation with the target variable (price_range)",
x = "Numeric Variable",
y = "Correlation") +
theme_minimal()
# Counts and Contingency Tables for Binary Variables
# Bluetooth variable
blue_table <- table(filtered_mobileTrain$blue, filtered_mobileTrain$price_range)
row.names(blue_table) <- c("Has Bluetooth", "No Bluetooth")
blue_table
# Dual Sim
dual_sim_table <- table(filtered_mobileTrain$dual_sim, filtered_mobileTrain$price_range)
row.names(dual_sim_table) <- c("Has Dual Sim", "No Dual Sim")
dual_sim_table
# 4G
fourG_table <- table(filtered_mobileTrain$four_g, filtered_mobileTrain$price_range)
row.names(fourG_table) <- c("Has 4G", "No 4G")
fourG_table
#3G
threeG_table <- table(filtered_mobileTrain$three_g, filtered_mobileTrain$price_range)
row.names(threeG_table) <- c("Has 3G", "No 3G")
threeG_table
# Touch Screen
touchscreen_table <- table(filtered_mobileTrain$touch_screen, filtered_mobileTrain$price_range)
row.names(touchscreen_table) <- c("Has Touch Screen", "No Touch Screen")
touchscreen_table
# Wifi
wifi_table <- table(filtered_mobileTrain$wifi, filtered_mobileTrain$price_range)
row.names(wifi_table) <- c("Has Wifi Capability", "No Wifi Capability")
wifi_table
# Remove variables that will not be used in model
final_mobileTrain = subset(filtered_mobileTrain, select = -c(blue, dual_sim, three_g, fc, n_cores, px_height, sc_h, clock_speed, m_dep) )
#Find totals of each possible price range outcome in final training set
sum(final_mobileTrain$price_range == "0")
sum(final_mobileTrain$price_range == "1")
sum(final_mobileTrain$price_range == "2")
sum(final_mobileTrain$price_range == "3")
#Find total records in final training set
dim(final_mobileTrain)
#Divide counts by total records for percentages
(496/1988)*100
(497/1988)*100
(497/1988)*100
(498/1988)*100
#Baseline model assigns all records to biggest category percentage
# Normalize Test Data
# Load necessary libraries
library(dplyr)
# Min-Max scaling
min_max_norm <- function(x) {(x - min(x)) / (max(x) - min(x))}
#Apply normalization to necessacry columns (all columns - target)
normalized_mobileTest <- as.data.frame(lapply(mobileTest[1:20], min_max_norm))
#Add target variable (price_range) back
normalized_mobileTest$price_range <- mobileTest$price_range
#Validate normalization and target variable
head(normalized_mobileTest)
#Remove Variables not being modeled + id
final_mobileTest = subset(filtered_mobileTrain, select = -c(xxxxx) )
