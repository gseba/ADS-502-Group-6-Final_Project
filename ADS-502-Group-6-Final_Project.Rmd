---
title: "ADS-502-Group-6-Final_Project"
output: html_document
date: "`r Sys.Date()`"
 markdown: 
    wrap: sentence
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# ADS 502 Applied Data Mining Final Group Project

## Group 6

### Dip Raj Bista + Logan Van Dine + Ghassan Seba

*`This data mining project aims to assist a mobile phone company in estimating the price range of their products based on various features such as RAM, Internal Memory, etc. By analyzing historical sales data from different mobile phone companies, the project seeks to uncover relationships between multiple features and ‘selling price.’ The objective is to provide actionable insights enabling the company to price their mobile phones appropriately and become more competitive while utilizing a classification model.`*

### Import dataset and describe characteristics such as dimensions, data types, file types, missing data, and statistical description of data.

```{r}
# Load data files
mobileTrain <- read.csv("train.csv", header = TRUE)
mobileTest <- read.csv("test.csv", header = TRUE)
```

```{r}
# Find training data set dimensions
dimenTrain <- dim(mobileTrain)
print(dimenTrain)
```

```{r}
# Find testing data set dimensions
dimenTest <- dim(mobileTest)
print(dimenTest)
```

```{r}
# suppressMessages()
suppressMessages({
  
# Load conflicted package 
library(conflicted)
  
# Load the tidyverse package
library(tidyverse)

# Get the column names and data types
colnamesTrain <- colnames(mobileTrain)
dtypeTrain <- sapply(mobileTrain, class)

# Clean the output
colnamesTrain <- str_pad(colnamesTrain, 10, side = "left")
dtypeTrain <- str_pad(dtypeTrain, 10, side = "left")

# Combine the two into a single data frame
df <- tibble(
  colname = colnamesTrain,
  dtype = dtypeTrain
)

# Print the data frame
print(df)
})
```

```{r}
# Load the tidyverse package
library(tidyverse)

# Get the column names and data types
colnamesTest <- colnames(mobileTest)
dtypeTest <- sapply(mobileTest, class)

# Clean the output
colnamesTest <- str_pad(colnamesTest, 10, side = "left")
dtypeTest <- str_pad(dtypeTest, 10, side = "left")

# Combine the two into a single data frame
df <- tibble(
  colname = colnamesTest,
  dtype = dtypeTest
)

# Print the data frame
print(df)

```

```{r}
# Display summary statistics for the training data set
summaryTrain <- summary(mobileTrain)

print(summaryTrain)

```

```{r}
# Display summary statistics for the training data set
summaryTest<- summary(mobileTest)

print(summaryTest)
```

```{r}
# Get the sum of missing values for each column
missingTrain <- colSums(is.na(mobileTrain))

# Column names
trainColumnNames <- names(missingTrain)

# Create a new data frame with column names and missing value counts
missingTrainTable <- data.frame(Column = trainColumnNames, MissingTrainCount = missingTrain)

# Print the tidy table to the console
cat(sprintf("%-15s %-15s\n", "Column Name", "NA Count"))
cat("---------------------------\n")
for (i in seq_along(missingTrainTable$Column)) {
  cat(sprintf("%-15s %-15d\n", missingTrainTable$Column[i], missingTrainTable$MissingTrainCount[i]))
}

```

```{r}
# Get the sum of missing values for each column
missingTest <- colSums(is.na(mobileTest))

# Column names
testColumnNames <- names(missingTest)

# Create a new data frame with column names and missing value counts
missingTestTable <- data.frame(Column = testColumnNames, MissingTestCount = missingTest)

# Print the tidy table to the console
cat(sprintf("%-15s %-15s\n", "Column Name", "NA Count"))
cat("---------------------------\n")
for (i in seq_along(missingTestTable$Column)) {
  cat(sprintf("%-15s %-15d\n", missingTestTable$Column[i], missingTestTable$MissingTestCount[i]))
}

```

## Data Description:

### Categorical Variables:

-   *`blue`*: Binary categorical variable indicating whether the mobile has Bluetooth (0 or 1).
-   *`dual_sim`*: Binary categorical variable indicating whether the mobile has dual SIM capability (0 or 1).
-   *`four_g`*: Binary categorical variable indicating whether the mobile supports 4G (0 or 1).
-   *`three_g`*: Binary categorical variable indicating whether the mobile supports 3G (0 or 1).
-   *`touch_screen`*: Binary categorical variable indicating whether the mobile has a touch screen (0 or 1).
-   *`wifi`*: Binary categorical variable indicating whether the mobile has Wi-Fi capability (0 or 1).
-   *`price_range`*: Categorical variable representing the price range of the mobile. It has discrete values (0, 1, 2, 3).

### Integer Variables:

-   *`battery_power`*: Discrete integer variable representing the battery power of the mobile.
-   *`fc`*: Discrete integer variable representing the front camera megapixels of the mobile.
-   *`int_memory`*: Discrete integer variable representing the internal memory in GB of the mobile.
-   *`mobile_wt`*: Discrete integer variable representing the weight of the mobile.
-   *`n_cores`*: Discrete integer variable representing the number of cores of the mobile's processor.
-   *`pc`*: Discrete integer variable representing the primary camera megapixels of the mobile.
-   *`px_height`*: Discrete integer variable representing the pixel height of the mobile.
-   *`px_width`*: Discrete integer variable representing the pixel width of the mobile.
-   *`ram`*: Discrete integer variable representing the RAM of the mobile in MB.
-   *`sc_h`*: Discrete integer variable representing the screen height of the mobile.
-   *`sc_w`*: Discrete integer variable representing the screen width of the mobile.
-   *`talk_time`*: Discrete integer variable representing the talk time of the mobile in hours.
-   *`id`*: Discrete integer variable representing the unique ID of the mobile (present in the test dataset).

### Numeric Variables:

-   *`clock_speed`*: Continuous numeric variable representing the clock speed of the mobile's processor.
-   *`m_dep`*: Continuous numeric variable representing the mobile depth.

### Normalize the training Data Set for proper analysis

```{r}
# Load necessary libraries
library(dplyr)

# Perform Min-Max scaling
normalized_mobileTrain <- mobileTrain %>%
  mutate(across(everything(), ~ (.-min(.)) / (max(.) - min(.))))

# Get the dimensions of the normalized data
dim(normalized_mobileTrain)


```

### Plot normalized continuous variables in training data set

```{r}
# Load necessary libraries
library(ggplot2)
library(tidyr)

# Define the number of rows and columns for the subplot matrix
num_rows <- 2
num_cols <- 6

# Select only the continuous and discrete integer columns from the mobileTrain dataset
selected_cols <- normalized_mobileTrain[, c("battery_power", "fc", "int_memory", "mobile_wt", 
                                 "n_cores", "pc", "px_height", "px_width", "ram", 
                                 "sc_h", "sc_w", "talk_time")]

# Convert the selected data frame to long format
mobileTrain_long <- tidyr::pivot_longer(selected_cols, 
                                       cols = everything(),
                                       names_to = "name", values_to = "value")

# Convert the 'name' column to a factor or character variable
mobileTrain_long$name <- as.factor(mobileTrain_long$name)

# Create the boxplot using ggplot2 with mean markers
trainingPlots <- ggplot(mobileTrain_long, aes(x = name, y = value)) +
  geom_boxplot() +
  stat_boxplot(geom = "errorbar", width = 0.2, position = position_dodge(width = 0.75)) +
  stat_summary(fun = mean, geom = "point", shape = 5, size = 3, color = "red",
               position = position_dodge(width = 0.75)) +
  facet_wrap(~name, scales = "free_x", ncol = num_cols) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Print the plot
print(trainingPlots)

```

### Identify outliers in the continuous variables via z-score

```{r}
# Function to calculate z-scores for a vector
calculate_z_scores <- function(x) {
  (x - mean(x)) / sd(x)
}

# Calculate z-scores for each column
z_scores <- mobileTrain_long %>%
  group_by(name) %>%
  mutate(z_score = calculate_z_scores(value))

# Set the z-score threshold for outlier detection
z_score_threshold <- 3

# Identify outliers based on z-scores
outliers <- z_scores %>%
  dplyr::filter(abs(z_score) > z_score_threshold)

# Print the outliers
print(outliers)
```

### Remove Outliers from data set

```{r}
# Load necessary libraries
library(dplyr)

# Calculate z-scores for each column
z_scores <- apply(normalized_mobileTrain, 2, function(x) abs((x - mean(x)) / sd(x)))

# Find rows with z-scores greater than 3 in any column
outliers <- rowSums(z_scores > 3) > 0

# Filter out the outliers from the dataset
filtered_mobileTrain <- normalized_mobileTrain[!outliers, ]

# get dimensions of the filtered dataset
dim(filtered_mobileTrain)

```

### Verify Impact of Outliers Removal

```{r}
# Load necessary libraries
library(dplyr)

# Calculate z-scores for each column
z_scores <- apply(normalized_mobileTrain, 2, function(x) abs((x - mean(x)) / sd(x)))

# Find rows with z-scores greater than 3 in any column
outliers <- rowSums(z_scores > 3) > 0

# Filter out the outliers from the dataset
filtered_mobileTrain <- normalized_mobileTrain[!outliers, ]

# Print summary statistics of the original dataset
print(summary(normalized_mobileTrain))

# Print summary statistics of the filtered dataset
print(summary(filtered_mobileTrain))
```

### Plot filtered data set to check for outliers

```{r}
library(ggplot2)

# Define the number of rows and columns for the subplot matrix
num_rows <- 2
num_cols <- 6

# Select only the numeric variables from the filtered_mobileTrain dataset
selected_cols <- filtered_mobileTrain %>%
  select(all_of(numeric_vars))

# Convert the column names to a factor or character variable
selected_cols <- selected_cols %>%
  gather(name, value)

# Create the boxplot using ggplot2 with mean markers
trainingPlotsFiltered <- ggplot(selected_cols, aes(x = name, y = value)) +
  geom_boxplot() +
  stat_boxplot(geom = "errorbar", width = 0.2, position = position_dodge(width = 0.75)) +
  stat_summary(fun = mean, geom = "point", shape = 5, size = 3, color = "red",
               position = position_dodge(width = 0.75)) +
  facet_wrap(~name, scales = "free_x", ncol = num_cols) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Print the plot
print(trainingPlotsFiltered)

```

```{r}
# Load necessary libraries
library(ggplot2)

# Select only the binary columns from the normalized_mobileTrain dataset
binary_cols <- mobileTrain[, c("blue", "dual_sim", "four_g", "three_g", "touch_screen", "wifi")]

# Get the table of counts for each binary variable
binary_counts <- lapply(binary_cols, table)

# Combine the counts into a single data frame
binary_df <- do.call(rbind, lapply(names(binary_counts), function(var_name) {
  data.frame(Variable = rep(var_name, 2),
             Value = as.factor(c("0", "1")),
             Count = as.numeric(binary_counts[[var_name]]))
}))

# Create the heatmap using ggplot2
heatmap_plot <- ggplot(binary_df, aes(x = Variable, y = Value, fill = Count)) +
  geom_tile(color = "white") +
  scale_fill_gradient(low = "white", high = "black") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Print the plot
print(heatmap_plot)
```

### Numeric Variable Covariance Analysis to identify strongly correlated features

```{r}
# Load necessary libraries
library(dplyr)

# Define the numeric and categorical variables
numeric_vars <- c("battery_power", "fc", "int_memory", "mobile_wt", "n_cores", "pc", "px_height", "px_width", "ram", "sc_h", "sc_w", "talk_time")
categorical_vars <- c("blue", "dual_sim", "four_g", "three_g", "touch_screen", "wifi")

# Perform Min-Max scaling and convert categorical variables to factors
normalized_mobileTrain <- mobileTrain %>%
  mutate_at(vars(all_of(categorical_vars)), as.factor) %>%
  mutate(across(all_of(numeric_vars), ~ (.-min(.)) / (max(.) - min(.))))

# Calculate the covariance matrix for numeric variables
cov_matrix <- cov(normalized_mobileTrain[, numeric_vars])

# Print covariance matrix with variable names
cat("Covariance Matrix for Numeric Variables:\n")
print(cov_matrix)


```

### Covariance Matrix Heatmap

```{r}
# Load necessary libraries
library(dplyr)
library(ggplot2)
library(reshape2)  # for melt function

# Define the numeric and categorical variables
numeric_vars <- c("battery_power", "fc", "int_memory", "mobile_wt", "n_cores", "pc", "px_height", "px_width", "ram", "sc_h", "sc_w", "talk_time")
categorical_vars <- c("blue", "dual_sim", "four_g", "three_g", "touch_screen", "wifi")

# Perform Min-Max scaling and convert categorical variables to factors
normalized_mobileTrain <- mobileTrain %>%
  mutate_at(vars(all_of(categorical_vars)), as.factor) %>%
  mutate(across(all_of(numeric_vars), ~ (.-min(.)) / (max(.) - min(.))))

# Calculate the correlation matrix for numeric variables
cor_matrix <- cor(normalized_mobileTrain[, numeric_vars])

# Create a heatmap of the correlation matrix
heatmap_data <- as.data.frame(as.table(cor_matrix))
colnames(heatmap_data) <- c("Variable_1", "Variable_2", "Correlation")  # Replace spaces with underscores

# Create the heatmap
ggplot(heatmap_data, aes(x = Variable_1, y = Variable_2, fill = Correlation)) +
  geom_tile() +
  scale_fill_gradient2(low = "white", mid = "blue", high = "yellow", midpoint = 0) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  labs(title = "Correlation Heatmap for Numeric Variables")

```

### Correlation with Target Variable

*`Higher absolute correlation values indicate potentially important features.`*

```{r}
# Calculate the correlation with the target variable
cor_with_target <- sapply(numeric_vars, function(var) cor(normalized_mobileTrain[[var]], normalized_mobileTrain$price_range))

# Print correlation values with the target variable neatly
cat("Correlation with the target variable (price_range):\n")
for (i in 1:length(numeric_vars)) {
  cat(numeric_vars[i], ": ", cor_with_target[i], "\n")
}
```

### Visualize the correlations between the numeric variables and the target variable "price_range" using a bar plot

```{r}
# Calculate the correlation with the target variable
cor_with_target <- sapply(numeric_vars, function(var) cor(normalized_mobileTrain[[var]], normalized_mobileTrain$price_range))

# Create a data frame for plotting
cor_df <- data.frame(Variable = numeric_vars, Correlation = cor_with_target)

# Plot correlation values with the target variable using a bar plot
library(ggplot2)

ggplot(cor_df, aes(x = reorder(Variable, -Correlation), y = Correlation)) +
  geom_bar(stat = "identity", fill = "dodgerblue") +
  coord_flip() +
  labs(title = "Correlation with the target variable (price_range)",
       x = "Numeric Variable",
       y = "Correlation") +
  theme_minimal()

```
